-- stylua: ignore start
-- stylua: ignore end

https://github.com/williamboman/mason-lspconfig.nvim
It's important that you set up the plugins in the following order:
mason.nvim
mason-lspconfig.nvim
Setup servers via lspconfig

lazy config
require('lazy').setup('module.plugins', {
  root = opt.root,
  concurrency = 2,
  defaults = { lazy = true },
  readme = { enabled = false },
  performance = { cache = { enabled = false } },
})

async run lua script
-- vim.api.nvim_command('echomsg "test"')
-- require('plenary.async').run(function() require('luasnip.loaders.from_vscode').load() end)

disable snippet
textDocument.completion.completionItem.snippetSupport = true

curl https://godbolt.org/api/compiler/g63/compile?options=-Wall --data-binary "int foo() { return 1; }"
curl https://godbolt.org/api/compiler/g122/compile --data-binary @godbolt_request_asm.json --header "Accept: application/json" --header "Content-Type: application/json" --output godbolt_response_asm.json

OS platform test
-- vim.loop.os_uname().version:match('Windows')
if jit then
  return string.lower(jit.os) ~= 'windows' and M.sep() or M.nt_sep()
if vim.fn.has('win32') == 1 then
  cmd = { 'explorer', uri }
  cmd = table.concat(cmd, ' '):gsub(M.kernel_sep(), M.nt_sep())
elseif vim.fn.has('macunix') == 1 then
  cmd = { 'open', uri }
else  
  M.is_windows = function() return vim.loop.os_uname().sysname == 'Windows_NT' end
M.is_linux = function() return vim.loop.os_uname().sysname == 'Linux' end

M.cached = cached
M.installed = function(name)
  -- if vim.tbl_isempty(cached) then
  -- for _, plugin in pairs(require('module.plugins')) do
  -- table.insert(cached, plugin[1])
  -- end
  -- end
  -- return vim.tbl_contains(cached, name)
  return true
end

['mrjones2014/legendary.nvim'] = function()
  local opts = { which_key = { auto_register = true } }
  opts = vim.tbl_deep_extend('error', opts, bindings.legendary())
  require('legendary').setup(opts)
end,

{ 'nvim-neo-tree/neo-tree.nvim', cmd = { 'Neotree' }, config = config('nvim-neo-tree/neo-tree.nvim') },
['nvim-neo-tree/neo-tree.nvim'] = function()
  vim.g.neo_tree_remove_legacy_commands = 1
  local opts = { async_directory_scan = 'never', log_level = 'trace', log_to_file = true, close_if_last_window = true, source_selector = { winbar = false, statusline = false } }
  opts = vim.tbl_deep_extend('error', opts, bindings.neotree())
  require('neo-tree').setup(opts)
end,
M.setup_autocmd = function()
  local augroup = vim.api.nvim_create_augroup('bindings.lua', {})
  vim.api.nvim_create_autocmd('BufEnter', {
    group = augroup,
    pattern = '*',
    callback = function(args)
      local info = vim.loop.fs_stat(args.file)
      if info and info.type == 'directory' then
        require('module.settings').config('nvim-neo-tree/neo-tree.nvim')()
        vim.cmd('Neotree position=current ' .. args.file)
      end
    end,
    desc = 'Hijack Directories',
  })
end
M.neotree = function()
  local telescope = require('telescope.builtin')
  local fs = require('neo-tree.sources.filesystem')
  return {
    window = {
      mappings = {
        ['e'] = function() vim.api.nvim_exec('Neotree focus filesystem left', true) end,
        ['b'] = function() vim.api.nvim_exec('Neotree focus buffers left', true) end,
        ['g'] = function() vim.api.nvim_exec('Neotree focus git_status left', true) end,
      },
    },
    filesystem = {
      window = {
        mappings = {
          ['O'] = 'system_open',
          ['tf'] = 'telescope_find',
          ['tg'] = 'telescope_grep',
        },
      },
      commands = {
        system_open = function(state)
          local path = state.tree:get_node():get_id()
          require('base').open(path)
        end,
        telescope_find = function(state)
          local path = state.tree:get_node():get_id()
          telescope.find_files(get_telescope_opts(path, function(name, state) fs.navigate(state, state.path, name) end, state))
        end,
        telescope_grep = function(state)
          local path = state.tree:get_node():get_id()
          telescope.live_grep(get_telescope_opts(path, function(name, state) fs.navigate(state, state.path, name) end, state))
        end,
      },
    },
  }
end